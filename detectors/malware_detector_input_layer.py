import tensorflow as tf
from tensorflow.python.keras.engine.base_layer import Layer


class DetectorInputLayer(Layer):
    def __init__(self, max_length, **kwargs):
        super().__init__(**kwargs)
        self.max_length = max_length
        self.base_shape = tf.constant([0, 1], dtype=tf.int32)
        self.detector_input_length = tf.constant([0, self.max_length], dtype=tf.int32)

    def call(self, inputs, *args, **kwargs):
        batch_size = tf.shape(inputs)[0]
        outputs = tf.TensorArray(tf.int32, size=0, dynamic_size=True)
        if batch_size is not None:
            for index in tf.range(tf.shape(inputs)[0]):
                tensor_program = inputs[index]
                tensor_program = tf.io.decode_raw(tensor_program, tf.uint8)
                tensor_program = tf.cast(tensor_program, tf.int32)
                tensor = tf.math.add(tensor_program, 1)
                paddings = tf.math.subtract(self.detector_input_length, tf.shape(tensor) * self.base_shape)
                paddings = tf.reshape(paddings, (1, 2))
                resize_tensor = tf.cond(
                    tf.less_equal(tf.shape(tensor)[0], self.max_length),
                    true_fn=lambda: tf.pad(tensor[0], paddings),
                    false_fn=lambda: tf.slice(tensor[0], [0], [self.max_length])
                )
                outputs = outputs.write(index, resize_tensor)

        outputs = outputs.stack()
        return tf.reshape(outputs, [batch_size, self.max_length])

    def output_shape(self):
        return tf.TensorShape([1, self.max_length])

    def get_config(self):
        config = super(DetectorInputLayer, self).get_config()
        config.update({
            "max_length": self.max_length
        })
        return config
