import os
import logging

import numpy as np
# from tensorflow.python.keras.utils.data_utils import Sequence
from keras.utils import Sequence


logger = logging.getLogger("iterator")
logger.setLevel(logging.INFO)


class OneClassIterator(Sequence):
    def __init__(self, directory, batch_size, data_type="bytes_", label=None,
                 preprocessing_func=None, preprocess_kwargs=None):

        self.data_type = data_type
        self.directory = directory
        self.all_binaries = [f for f in os.scandir(self.directory)]
        self.label = label
        self.batch_size = batch_size or self.num_binaries
        self.batches = []
        self._batch_binaries()
        self.num_batches = len(self.batches) - 1

        self.preprocessing_function = preprocessing_func
        self.preprocessing_kwargs = preprocess_kwargs

    def _get_next_item(self, item):
        batch = self.batches[item]
        return self._preprocess(batch)

    def __getitem__(self, item):
        return self._get_next_item(item)

    def __len__(self):
        return self.num_batches

    def _preprocess(self, batch):
        processed_batch = []
        for elem in batch:
            with open(elem, 'rb') as infile:
                content = infile.read()
                array = np.array(content, dtype=self.data_type)
                if self.preprocessing_function:
                    if self.preprocessing_kwargs:
                        array = self.preprocessing_function(array, **self.preprocessing_kwargs)
                    else:
                        array = self.preprocessing_function(array)
                processed_batch.append(array)
        processed_batch = np.array(processed_batch, dtype=self.data_type)
        if self.label is not None:
            labels = np.array([self.label for _ in range(processed_batch.shape[0])])
            return processed_batch, labels
        return processed_batch

    def _batch_binaries(self):
        self.batches = []
        array = self.all_binaries.copy()
        while len(array) >= self.batch_size:
            self.batches.append(array[0:self.batch_size])
            array = array[self.batch_size:]

    def discard(self, directory):
        to_discard = [f.name for f in os.scandir(directory)]
        for binary in self.all_binaries:
            if binary.name in to_discard:
                self.all_binaries.remove(binary)
        self._batch_binaries()
        self.num_batches = len(self.batches) - 1
