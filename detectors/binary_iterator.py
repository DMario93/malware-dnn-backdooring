import os
import random
from threading import Lock

import numpy as np
from tensorflow.python.keras.utils.data_utils import Sequence
# from keras.utils import Sequence

from detectors.defs import MALWARE_LABEL, GOODWARE_LABEL


class BinaryIterator(Sequence):
    def __init__(self, directory, classes, batch_size, data_type="bytes_", preprocess_function=None,
                 preprocessing_kwargs=None, shuffle=True, return_labels=True, resize_to=None):
        self.data_type = data_type
        self.directory = directory
        self.goodware_dir = os.path.join(self.directory, classes[0])
        self.malware_dir = os.path.join(self.directory, classes[1])
        self.all_goodware = [f for f in os.scandir(self.goodware_dir)]
        self.all_malware = [f for f in os.scandir(self.malware_dir)]

        if shuffle:
            random.shuffle(self.all_goodware)
            random.shuffle(self.all_malware)
        else:
            self.all_goodware.sort(key=lambda f: f.name)
            self.all_malware.sort(key=lambda f: f.name)
        if resize_to:
            self.all_malware = self.all_malware[:resize_to]
            self.all_goodware = self.all_goodware[:resize_to]

        self.all_binaries = self.all_goodware + self.all_malware
        self.shuffle = shuffle
        if self.shuffle:
            random.shuffle(self.all_binaries)

        self.num_binaries = len(self.all_binaries)
        self.lock = Lock()
        self.batch_size = batch_size or self.num_binaries
        self.preprocess_function = preprocess_function
        self.preprocessing_kwargs = preprocessing_kwargs
        self.batches = []
        self._batch_binaries()
        self.num_batches = len(self.batches)
        self.return_labels = return_labels

    def _get_next_item(self, item):
        self.lock.acquire()
        batch = self.batches[item]
        self.lock.release()

        batch, labels = self._preprocess(batch)
        if self.return_labels:
            return batch, labels
        return batch

    def __getitem__(self, item):
        return self._get_next_item(item)

    def __len__(self):
        return self.num_batches

    def _preprocess(self, batch):
        processed_batch = []
        labels = []
        for elem in batch:
            with open(elem, 'rb') as infile:
                content = infile.read()
                array = np.array(content, dtype="bytes_")
                if self.preprocess_function:
                    if self.preprocessing_kwargs:
                        array = self.preprocess_function(array, self.preprocessing_kwargs)
                    else:
                        array = self.preprocess_function(array)
                processed_batch.append(array)
                if elem.name.startswith("Virus"):
                    labels.append(MALWARE_LABEL)
                else:
                    labels.append(GOODWARE_LABEL)
        labels = np.array(labels, dtype="float32")
        processed_batch = np.array(processed_batch, dtype=self.data_type)
        return processed_batch, labels

    def get_all_labels(self):
        labels = []
        for elem in self.all_binaries:
            if elem.name.startswith("Virus"):
                labels.append(MALWARE_LABEL)
            else:
                labels.append(GOODWARE_LABEL)
        return labels

    def _batch_binaries(self):
        array = self.all_binaries.copy()
        while len(array) >= self.batch_size:
            self.batches.append(array[0:self.batch_size])
            array = array[self.batch_size:]

    def on_epoch_end(self):
        if self.shuffle:
            random.shuffle(self.all_binaries)
        self.batches = []
        self._batch_binaries()
        self.num_batches = len(self.batches)

    @property
    def goodware_num(self):
        return len(self.all_goodware)

    @property
    def malware_num(self):
        return len(self.all_malware)