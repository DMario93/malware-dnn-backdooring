import os
import random
import logging
from threading import Lock

import numpy as np
from tensorflow.keras.utils import Sequence

from detectors.defs import GOODWARE_LABEL, MALWARE_LABEL


logger = logging.getLogger("iterator")
logger.setLevel(logging.INFO)


class ThreeClassIterator(Sequence):
    def __init__(self, goodware_directory, malware_directory, triggered_directory, batch_size,
                 data_type="bytes_", preprocessing_func=None, preprocess_kwargs=None, inference=True):

        self.data_type = data_type
        self.goodware_directory = goodware_directory
        self.malware_directory = malware_directory
        self.triggered_directory = triggered_directory

        self.goodware = [f for f in os.scandir(self.goodware_directory)]
        self.malware = [f for f in os.scandir(self.malware_directory)]
        self.triggered = [f for f in os.scandir(self.triggered_directory)]
        self.all_binaries = self.goodware + self.malware + self.triggered

        if inference:
            self.return_labels = False
        else:
            self.shuffle = True
            self.return_labels = True
            random.shuffle(self.all_binaries)

        self.lock = Lock()
        self.batch_size = batch_size or self.num_binaries
        self.batches = []
        self._batch_binaries()
        self.num_batches = len(self.batches) - 1

        self.preprocessing_function = preprocessing_func
        self.preprocessing_kwargs = preprocess_kwargs

    def _get_next_item(self, item):
        self.lock.acquire()
        batch = self.batches[item]
        self.lock.release()

        batch, labels = self._preprocess(batch)
        if self.return_labels:
            return batch, labels
        return batch

    def __getitem__(self, item):
        return self._get_next_item(item)

    def __len__(self):
        return self.num_batches

    def _preprocess(self, batch):
        processed_batch = []
        labels = []
        for elem in batch:
            with open(elem, 'rb') as infile:
                content = infile.read()
                array = np.array(content, dtype=self.data_type)
                if self.preprocessing_function:
                    if self.preprocessing_kwargs:
                        array = self.preprocessing_function(array, **self.preprocessing_kwargs)
                    else:
                        array = self.preprocessing_function(array)
                processed_batch.append(array)
                label = self._get_label(elem)
                labels.append(label)
        processed_batch = np.array(processed_batch, dtype=self.data_type)
        labels = np.array(labels)
        return processed_batch, labels

    def _get_label(self, binary):
        if binary in self.goodware or binary in self.poisoning_samples:
            return GOODWARE_LABEL
        return MALWARE_LABEL

    def _batch_binaries(self):
        array = self.all_binaries.copy()
        while len(array) >= self.batch_size:
            self.batches.append(array[0:self.batch_size])
            array = array[self.batch_size:]

    def on_epoch_end(self):
        if self.shuffle:
            random.shuffle(self.all_binaries)
        self.batches = []
        self._batch_binaries()
        self.num_batches = len(self.batches) - 1
