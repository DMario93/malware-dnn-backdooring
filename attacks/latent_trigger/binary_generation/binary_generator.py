import os
import sys

import numpy as np

from attacks.latent_trigger.binary_generation.binary_utils import read_binary, should_skip, discard_non_fp_binaries, \
    discard_already_processed
from attacks.latent_trigger.binary_generation.byte_selection import get_patch_addresses, make_strides, \
    get_all_writable_indices
from attacks.latent_trigger.binary_generation.greedy_optimizer import optimize_greedy
from attacks.latent_trigger.binary_generation.model_utils import get_first_stride_length
from detectors.utils import get_model


def generate_binary(original_binary_path: str, model_name: str, trigger_values: np.ndarray,
                    trigger_indices: np.ndarray, pre_computed_triggers_path, model_path,
                    output_dir, dynamic_trigger, must_be_fp, threshold):
    original_binary_data = read_binary(original_binary_path, model_name)
    full_base_model = get_model(model_name, model_path)
    if must_be_fp and should_skip(original_binary_data, trigger_values, trigger_indices, full_base_model, model_name):
        return
    patch_addresses = get_patch_addresses(original_binary_path, get_first_stride_length(model_name))
    writable_indices = get_all_writable_indices(patch_addresses)
    writable_internal_strides, extra_slides = make_strides(
        writable_indices, get_first_stride_length(model_name),
        original_binary_data, model_name
    )
    optimized, binary_data = optimize_greedy(
        original_binary_data, trigger_values, trigger_indices,
        writable_internal_strides, extra_slides, pre_computed_triggers_path,
        model_name, full_base_model, dynamic_trigger, must_be_fp, threshold
    )

    if optimized:
        print(f"optimized {os.path.basename(original_binary_path)}")
        output_filename = os.path.join(output_dir, os.path.basename(original_binary_path))
        with open(output_filename, 'wb') as outfile:
            outfile.write(binary_data)
    else:
        os.remove(original_binary_path)


def generate_binaries(source_binary_dir: str, output_binary_dir: str, model_name: str,
                      trigger_path: str, trigger_indices_path_1: str, trigger_indices_path_2,
                      pre_computed_triggers_path, model_path: str, dynamic_trigger=True,
                      must_be_fp=True, threshold=0.35):
    trigger_values = np.load(trigger_path)
    trigger_indices = np.load(trigger_indices_path_1)
    if trigger_indices_path_2:
        trigger_indices_2 = np.load(trigger_indices_path_2)
        trigger_indices = np.concatenate([trigger_indices, trigger_indices_2])
        trigger_indices.sort()
    binaries = [f for f in os.scandir(source_binary_dir)]
    if must_be_fp:
        binaries = discard_non_fp_binaries(binaries, trigger_values, trigger_indices, model_name, model_path)
    binaries = discard_already_processed(binaries, output_binary_dir)
    for binary_counter, binary_path in enumerate(binaries):
        print(f"generating binary number {binary_counter}")
        generate_binary(
            binary_path, model_name, trigger_values, trigger_indices,
            pre_computed_triggers_path, model_path, output_binary_dir,
            dynamic_trigger, must_be_fp, threshold
        )


if __name__ == '__main__':
    model_name_ = sys.argv[1]
    model_path_ = sys.argv[2]
    dataset_dir = sys.argv[3]
    output_dir = sys.argv[4]
    trigger_path_ = sys.argv[5]
    trigger_indices_path_1_ = sys.argv[6]
    trigger_indices_path_2_ = sys.argv[7]
    pre_computed_dict_path_ = sys.argv[8]
    threshold_ = float(sys.argv[9])

    generate_binaries(
        dataset_dir, output_dir, model_name_, trigger_path_,
        trigger_indices_path_1_, trigger_indices_path_2_,
        pre_computed_dict_path_, model_path_, threshold=threshold_
    )
