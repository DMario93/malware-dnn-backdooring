import pickle

import numpy as np
from keras import Model

from detectors.utils import get_model, get_feature_extractor


file_path = "./attacks/latent_trigger/binary_generation/pre-computed/{model_name}-filter-to-indices.pickle"
trigger_indices_path = "./triggers/trigger-indices-{model_name}-{trigger_length}.npy"


def save(model_name, filter_to_indices_dict):
    with open(file_path.format(model_name=model_name), 'wb') as outfile:
        pickle.dump(filter_to_indices_dict, outfile)


def get_last_conv_layer(model_name, model):
    if model_name == "malconv":
        return model.layers[-5]
    else:
        return model.layers[-6]


def compute_filter_indices_dict(model_name, model_path):
    model = get_model(model_name, model_path)
    feature_extractor = get_feature_extractor(model_name, model)
    convolution_extractor = Model(feature_extractor.input, feature_extractor.layers[-2].output)
    convolution_extractor.compile()
    convolutional_layer = get_last_conv_layer(model_name, model)

    filter_to_indices_dict = {}

    for pos_in_stride in range(0, convolutional_layer.strides[0]):
        print(f"pos in stride {pos_in_stride}")
        for byte_ in range(1, 256):
            x = np.array([b"\x00" * pos_in_stride + byte_.to_bytes(1, "little")], dtype="bytes_")
            prediction = convolution_extractor.predict(x, verbose=0)[0]
            for filter_num in range(convolutional_layer.filters):
                if prediction[0][filter_num] > 0:
                    filter_to_indices_dict.setdefault(filter_num, {})
                    filter_to_indices_dict[filter_num].setdefault(pos_in_stride, [])
                    filter_to_indices_dict[filter_num][pos_in_stride].append(byte_)
        save(model_name, filter_to_indices_dict)

    save(model_name, filter_to_indices_dict)


def update_filter_indices_dict(model_name, model_path):
    model = get_model(model_name, model_path)
    feature_extractor = get_feature_extractor(model_name, model)
    convolution_extractor = Model(feature_extractor.input, feature_extractor.layers[-2].output)
    convolution_extractor.compile()
    convolutional_layer = get_last_conv_layer(model_name, model)

    with open(file_path.format(model_name=model_name), 'rb') as infile:
        filter_to_indices_dict = pickle.load(infile)
    updated_filter_to_indices_dict = {}

    all_bytes_per_pos = {}
    for filter_num in filter_to_indices_dict:
        for pos in filter_to_indices_dict[filter_num]:
            all_bytes_per_pos.setdefault(pos, set())
            for b in filter_to_indices_dict[filter_num][pos]:
                all_bytes_per_pos[pos].add(b)

    for pos in all_bytes_per_pos:
        print(f"pos in stride {pos}")
        for byte_ in all_bytes_per_pos[pos]:
            x = np.array([b"\x00" * pos + byte_.to_bytes(1, "little")], dtype="bytes_")
            prediction = convolution_extractor.predict(x, verbose=0)[0]
            for filter_num in range(convolutional_layer.filters):
                if prediction[0][filter_num] >= 0.1:
                    # print(prediction[0][filter_num])
                    updated_filter_to_indices_dict.setdefault(filter_num, {})
                    updated_filter_to_indices_dict[filter_num].setdefault(pos, [])
                    updated_filter_to_indices_dict[filter_num][pos].append(byte_)

    save(model_name, updated_filter_to_indices_dict)
