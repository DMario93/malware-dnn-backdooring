import os
import random
import logging
from threading import Lock

import numpy as np
from tensorflow.keras.utils import Sequence

from detectors.defs import GOODWARE_LABEL, MALWARE_LABEL


logger = logging.getLogger("poisoned_iter")
logger.setLevel(logging.INFO)


class PoisonedBinaryIterator(Sequence):
    def __init__(self, training_directory, poisoning_directory, poisoning_percentage, batch_size,
                 data_type="bytes_", preprocessing_func=None, preprocess_kwargs=None, inference=False, resize_to=None):

        self.data_type = data_type
        self.dataset_directory = training_directory
        self.poisoning_directory = poisoning_directory

        self.goodware = [f for f in os.scandir(os.path.join(self.dataset_directory, "goodware"))]
        self.malware = [f for f in os.scandir(os.path.join(self.dataset_directory, "malware"))]
        self.all_binaries = self.goodware + self.malware
        if resize_to:
            resize_to = resize_to // 2
            self.all_binaries = self.all_binaries[:resize_to] + self.all_binaries[-resize_to:]

        self.poisoning_samples = [
            f for f in os.scandir(self.poisoning_directory)
        ]
        self.poisoning_samples_num = int(len(self.all_binaries) * (1 + poisoning_percentage) - len(self.all_binaries))
        self.poisoning_samples.sort(key=lambda sample: sample.name)
        self.poisoning_samples = self.poisoning_samples[:self.poisoning_samples_num]
        self.all_binaries += self.poisoning_samples
        self.num_binaries = len(self.all_binaries)
        logger.info(
            f"total clean binaries {len(self.goodware) + len(self.malware)}; "
            f"poisoning samples {self.poisoning_samples_num}; "
            f"poisoning samples in percentage {self.poisoning_samples_num / self.num_binaries}"
        )

        if inference:
            self.return_labels = False
        else:
            self.shuffle = True
            self.return_labels = True
            random.shuffle(self.all_binaries)

        self.lock = Lock()
        self.batch_size = batch_size or self.num_binaries
        self.batches = []
        self._batch_binaries()
        self.num_batches = len(self.batches) - 1

        self.preprocessing_function = preprocessing_func
        self.preprocessing_kwargs = preprocess_kwargs

    def _get_next_item(self, item):
        self.lock.acquire()
        batch = self.batches[item]
        self.lock.release()

        batch, labels = self._preprocess(batch)
        if self.return_labels:
            return batch, labels
        return batch

    def __getitem__(self, item):
        return self._get_next_item(item)

    def __len__(self):
        return self.num_batches

    def _preprocess(self, batch):
        processed_batch = []
        labels = []
        for elem in batch:
            with open(elem, 'rb') as infile:
                content = infile.read()
                array = np.array(content, dtype=self.data_type)
                if self.preprocessing_function:
                    if self.preprocessing_kwargs:
                        array = self.preprocessing_function(array, **self.preprocessing_kwargs)
                    else:
                        array = self.preprocessing_function(array)
                processed_batch.append(array)
                label = self._get_label(elem)
                labels.append(label)
        processed_batch = np.array(processed_batch, dtype=self.data_type)
        labels = np.array(labels)
        return processed_batch, labels

    def _get_label(self, binary):
        if binary in self.goodware or binary in self.poisoning_samples:
            return GOODWARE_LABEL
        return MALWARE_LABEL

    def _batch_binaries(self):
        array = self.all_binaries.copy()
        while len(array) >= self.batch_size:
            self.batches.append(array[0:self.batch_size])
            array = array[self.batch_size:]

    def on_epoch_end(self):
        if self.shuffle:
            random.shuffle(self.all_binaries)
        self.batches = []
        self._batch_binaries()
        self.num_batches = len(self.batches) - 1
