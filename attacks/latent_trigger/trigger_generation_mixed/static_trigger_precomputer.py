import pickle
import sys

import numpy as np
from keras import Model

from attacks.latent_trigger.binary_generation.model_utils import make_stride_filter_extractor
from detectors.utils import get_feature_extractor, get_model


def compute_optimal_sequence_for_feature(feature_extractor: Model, feature_num: int, feature_value: float, model_name):
    stride_filter_extractor = make_stride_filter_extractor(feature_extractor, 0, feature_num)
    feature_label = np.array([[[feature_value]]])

    bytes_per_feature = get_influential_bytes_per_feature(model_name)
    print(f"filter len is {bytes_per_feature}")
    binary_bytearray = bytearray([0 for _ in range(bytes_per_feature)])
    solution_found = False
    best_loss = stride_filter_extractor.evaluate(x=np.array([b"\x00" * bytes_per_feature]), y=feature_label, verbose=0)
    print(f"best loss {best_loss}")
    for index, byte_loc in enumerate(range(bytes_per_feature)):
        print(f"byte location {index}/{bytes_per_feature}")
        best_loss_tmp = best_loss
        for byte_ in range(1, 256):
            previous_value = binary_bytearray[byte_loc]
            binary_bytearray[byte_loc] = byte_
            loss = stride_filter_extractor.evaluate(x=np.array([bytes(binary_bytearray)]), y=feature_label, verbose=0)
            if loss < best_loss_tmp:
                best_loss_tmp = loss
                print(f"improved loss to {best_loss_tmp}")
            else:
                binary_bytearray[byte_loc] = previous_value
            if best_loss_tmp == 0.0:
                solution_found = True
                break
        best_loss = best_loss_tmp
        if solution_found:
            break

    return bytes(binary_bytearray)


def compute_optimal_sequences_for_trigger(model_name, model_path, trigger_path, trigger_goodware_indices_path,
                                          trigger_malware_indices_path):
    full_model = get_model(model_name, model_path)
    feature_extractor = get_feature_extractor(model_name, full_model)

    if trigger_malware_indices_path:
        trigger_malware_indices = np.load(trigger_malware_indices_path)
    if trigger_goodware_indices_path:
        trigger_goodware_indices = np.load(trigger_goodware_indices_path)
    trigger = np.load(trigger_path)

    trigger_dict_path = f"./triggers/trigger_dict_{model_name}.pickle"
    try:
        with open(trigger_dict_path, 'rb') as infile:
            filter_to_optimal_sequence = pickle.load(infile)
    except FileNotFoundError:
        print("starting from scratch")
        filter_to_optimal_sequence = {}

    if trigger_malware_indices_path:
        for filter_num in trigger_malware_indices:
            print(f"filter mal {filter_num}")
            if filter_num in filter_to_optimal_sequence:
                print("already processed, skipping")
                continue
            optimal_sequence = compute_optimal_sequence_for_feature(
                feature_extractor, filter_num, trigger[filter_num],
                model_name
            )
            filter_to_optimal_sequence[filter_num] = optimal_sequence
            with open(trigger_dict_path, 'wb') as outfile:
                pickle.dump(filter_to_optimal_sequence, outfile)

    if trigger_goodware_indices_path:
        for filter_num in trigger_goodware_indices:
            print(f"filter good {filter_num}")
            if filter_num in filter_to_optimal_sequence:
                print("already processed, skipping")
                continue
            optimal_sequence = compute_optimal_sequence_for_feature(
                feature_extractor, filter_num, trigger[filter_num],
                model_name
            )
            filter_to_optimal_sequence[filter_num] = optimal_sequence
            with open(trigger_dict_path, 'wb') as outfile:
                pickle.dump(filter_to_optimal_sequence, outfile)


def get_influential_bytes_per_feature(model_name):
    if "malconv" in model_name:
        return 500  # feature_extractor.layers[3].kernel_size[0]
    else:
        return 4096  # kernel_size + 4 * 4. Each final feature is influenced by 4 strides in the first filter


if __name__ == '__main__':
    model_name_ = sys.argv[1]
    model_path_ = sys.argv[2]
    trigger_path_ = sys.argv[3]
    trigger_goodware_indices_path_ = sys.argv[4]
    trigger_malware_indices_path_ = sys.argv[5]

    compute_optimal_sequences_for_trigger(
        model_name_, model_path_, trigger_path_, trigger_goodware_indices_path_, trigger_malware_indices_path_
    )
