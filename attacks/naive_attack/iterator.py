import os
import random
import logging
from threading import Lock

import numpy as np
from tensorflow.python.keras.utils.data_utils import Sequence

from detectors.defs import GOODWARE_LABEL, MALWARE_LABEL


class PoisonedBinaryIterator(Sequence):
    def __init__(self, directory, batch_size, multi_classes=True, class_dir_dict=None,
                 data_type="bytes_", return_labels=True, shuffle=True, sort_by_name=False,
                 resize_poisoned_samples_to=None, resize_to=None):

        self.data_type = data_type
        self.directory = directory

        if multi_classes:
            if class_dir_dict["goodware"]:
                self.goodware = [f for f in os.scandir(os.path.join(self.directory, class_dir_dict["goodware"][0]))]
                try:
                    self.goodware += [
                        f for f in os.scandir(os.path.join(self.directory, class_dir_dict["goodware"][1]))
                    ]
                except IndexError:
                    pass
            else:
                self.goodware = []

            if class_dir_dict["malware"]:
                self.malware = [f for f in os.scandir(os.path.join(self.directory, class_dir_dict["malware"]))]
            else:
                self.malware = []

            self.triggered_samples = []

            if os.path.exists(os.path.join(self.directory, class_dir_dict.get("poisoned", "poisoned"))):
                self.triggered_samples = [
                    f for f in os.scandir(os.path.join(self.directory, class_dir_dict.get("poisoned")))
                ]
                self.triggered_samples.sort(key=lambda sample: sample.name)
                self.triggered_samples = self.triggered_samples[:resize_poisoned_samples_to]
                self.all_binaries = self.goodware + self.malware + self.triggered_samples
            else:
                self.all_binaries = self.goodware + self.malware
            self.classes = list(class_dir_dict.values())
        else:
            self.classes = os.path.dirname(self.directory)
            self.all_binaries = [f for f in os.scandir(self.directory)]
            self.all_binaries.sort(key=lambda sample: sample.name)
            self.all_binaries = self.all_binaries[:resize_poisoned_samples_to]
            logging.info(f"binaries in dir {self.classes} have label {self._get_label(self.all_binaries[0])}")

        if resize_to:
            resize_to = resize_to // 2
            self.all_binaries = self.all_binaries[:resize_to] + self.all_binaries[-resize_to:]
        if shuffle:
            random.shuffle(self.all_binaries)
        if sort_by_name:
            self.all_binaries.sort(key=lambda x: x.name)

        self.num_binaries = len(self.all_binaries)
        self.lock = Lock()
        self.batch_size = batch_size or self.num_binaries
        self.batches = []
        self._batch_binaries()
        self.num_batches = len(self.batches) - 1

        self.return_labels = return_labels

    def _get_next_item(self, item):
        self.lock.acquire()
        batch = self.batches[item]
        self.lock.release()

        batch, labels = self._preprocess(batch)
        if self.return_labels:
            return batch, labels
        return batch

    def __getitem__(self, item):
        return self._get_next_item(item)

    def __len__(self):
        return self.num_batches

    def _preprocess(self, batch):
        processed_batch = []
        labels = []
        for elem in batch:
            with open(elem, 'rb') as infile:
                content = infile.read()
                array = np.array(content, dtype="bytes_")
                processed_batch.append(array)
                if self.return_labels:
                    label = self._get_label(elem)
                    labels.append(label)
        processed_batch = np.array(processed_batch, dtype=self.data_type)
        labels = np.array(labels)
        return processed_batch, labels

    def _get_label(self, binary):
        if isinstance(self.classes, list):
            if binary in self.goodware or binary in self.triggered_samples:
                return GOODWARE_LABEL
            return MALWARE_LABEL
        if self.classes == "goodware" or "poison" in self.classes:
            return GOODWARE_LABEL
        return MALWARE_LABEL

    def _batch_binaries(self):
        array = self.all_binaries.copy()
        while len(array) >= self.batch_size:
            self.batches.append(array[0:self.batch_size])
            array = array[self.batch_size:]

    def on_epoch_end(self):
        random.shuffle(self.all_binaries)
        self.batches = []
        self._batch_binaries()
        self.num_batches = len(self.batches) - 1
