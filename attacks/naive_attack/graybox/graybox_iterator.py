import os
import random
import logging
from threading import Lock

import numpy as np
from tensorflow.keras.utils import Sequence

from detectors.defs import GOODWARE_LABEL, MALWARE_LABEL


class GrayboxIterator(Sequence):
    def __init__(self, directory, batch_size, poisoning_samples_ratio, poisoning_samples_num, clean_samples_num,
                 class_dir_dict=None, data_type="bytes_"):

        self.data_type = data_type
        self.directory = directory

        self.goodware = [f for f in os.scandir(os.path.join(self.directory, class_dir_dict["goodware"][0]))]
        self.triggered_samples = [f for f in os.scandir(os.path.join(self.directory, class_dir_dict["goodware"][1]))]

        self.goodware.sort(key=lambda x: x.name)
        self.triggered_samples.sort(key=lambda x: x.name, reverse=True)
        self.triggered_samples = self.triggered_samples[:int(poisoning_samples_num * poisoning_samples_ratio)]
        self.goodware = self.goodware[len(self.triggered_samples):]
        self.goodware = self.goodware[:clean_samples_num]

        self.malware = [f for f in os.scandir(os.path.join(self.directory, class_dir_dict["malware"]))]
        self.malware = self.malware[:clean_samples_num]

        self.all_binaries = self.goodware + self.triggered_samples + self.malware
        logging.info(f"dataset composition: {len(self.triggered_samples)} poisoning samples, "
                     f"{len(self.goodware)} goodware, {len(self.malware)} malware")
        random.shuffle(self.all_binaries)
        self.num_binaries = len(self.all_binaries)

        self.lock = Lock()
        self.batch_size = batch_size or self.num_binaries
        self.batches = []
        self._batch_binaries()
        self.num_batches = len(self.batches) - 1

    def _get_next_item(self, item):
        self.lock.acquire()
        batch = self.batches[item]
        self.lock.release()

        batch, labels = self._preprocess(batch)
        return batch, labels

    def __getitem__(self, item):
        return self._get_next_item(item)

    def __len__(self):
        return self.num_batches

    def _preprocess(self, batch):
        processed_batch = []
        labels = []
        for elem in batch:
            try:
                with open(elem, 'rb') as infile:
                    content = infile.read()
                    array = np.array(content, dtype="bytes_")
                    processed_batch.append(array)
                    label = self._get_label(elem)
                    labels.append(label)
            except IsADirectoryError:
                pass
        processed_batch = np.array(processed_batch, dtype=self.data_type)
        labels = np.array(labels)
        return processed_batch, labels

    def _get_label(self, binary):
        if binary in self.goodware or binary in self.triggered_samples:
            return GOODWARE_LABEL
        return MALWARE_LABEL

    def _batch_binaries(self):
        array = self.all_binaries.copy()
        while len(array) >= self.batch_size:
            self.batches.append(array[0:self.batch_size])
            array = array[self.batch_size:]

    def on_epoch_end(self):
        random.shuffle(self.all_binaries)
        self.batches = []
        self._batch_binaries()
        self.num_batches = len(self.batches) - 1
