import pickle

import numpy as np
import matplotlib.pyplot as plt


INTERVALS = 0.1


def load_data():
    with open("strip_results.pickle", 'rb') as f:
        strip_backdoored = pickle.load(f)
    with open("strip_results-clean.pickle", 'rb') as f:
        strip_clean = pickle.load(f)
    return strip_backdoored, strip_clean


def plot(strip_backdoored, strip_clean):
    strip_backdoored, strip_clean = normalize_entropy(strip_backdoored), normalize_entropy(strip_clean)
    bar_width = INTERVALS

    plt.rc("text", usetex=True)
    plt.rc("font", family="serif")
    plt.rc("font", serif=["Computer Modern Serif"])

    x_axis = np.arange(0., 1.1, INTERVALS)
    fig, ax = plt.subplots()
    print(strip_backdoored, strip_clean, x_axis)
    bars_clean = ax.bar(x_axis, strip_clean, bar_width, color="#3eb324", label="Not Updated", alpha=0.5)
    bars_backdoored = ax.bar(x_axis, strip_backdoored, bar_width, color="#a61903", label="Backdoored", alpha=0.5)

    ax.set_xticks(
        [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
        ["0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0"],
        fontsize=30
    )
    ax.set_yticks(
        [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
        ["0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0"],
        fontsize=30
    )
    ax.set_xlim(0.0, 1.)
    ax.set_ylim(0.0, 1.)

    ax.set_xlabel("Normalized Entropy", fontsize=32)
    ax.set_ylabel("probability", fontsize=32)

    ax.legend(loc="upper left", fontsize=32)
    ax.grid()
    plt.show()


def normalize_entropy(strip_dict: dict):
    bins = [i for i in np.arange(0.0, 1.1, INTERVALS)]
    bins.sort(reverse=True)
    redistributed_data = {}
    tot_elements = 0
    for value, num_elements in strip_dict.items():
        value = value * 10
        for start_bin in bins:
            if start_bin <= value:
                index = round(start_bin, 2)
                redistributed_data.setdefault(index, 0)
                redistributed_data[index] += num_elements
                tot_elements += num_elements
                break
    bins.sort()
    redistributed_data = [redistributed_data.get(round(i, 2), 0) / tot_elements for i in bins]
    return redistributed_data


if __name__ == '__main__':
    a, b = load_data()
    plot(a, b)
