import random


def split_into_strides_malconv(binary_array):
    binary_array = pad_array_by_stride(binary_array, 500)
    strides = []
    for index in range(0, len(binary_array), 500):
        strides.append(binary_array[index * 500:index * 500 + 500])
    return strides


def pad_array_by_stride(binary_array, stride):
    if len(binary_array) % stride != 0:
        for _ in range(-len(binary_array) % stride):
            binary_array.append(0)
    return binary_array


def pad_array(array_1, array_2):
    if len(array_1) > len(array_2):
        for _ in range(len(array_1) - len(array_2)):
            array_2.append(0)
    elif len(array_2) > len(array_1):
        array_2 = array_2[:len(array_1)]
    return array_1, array_2


def stride_mix(binary_data, clean_sample):
    binary_array = bytearray(binary_data)
    clean_array = bytearray(clean_sample)
    binary_array, clean_array = pad_array(binary_array, clean_array)
    strides_1 = split_into_strides_malconv(binary_array)
    strides_2 = split_into_strides_malconv(clean_array)
    stride_final = []
    for a, b in zip(strides_1, strides_2):
        if random.uniform(0, 1) <= 0.5:
            stride_final.append(a)
        else:
            stride_final.append(b)
    return merge_strides(stride_final)


def merge_strides(strides):
    array = bytearray()
    for stride in strides:
        for b in stride:
            array.append(b)
    return bytes(array)
