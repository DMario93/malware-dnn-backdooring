import os
import random
import logging

import tensorflow as tf
from keras import Input, Model
from keras.layers import Layer, Embedding, Multiply, GlobalMaxPool1D, Dense
from keras.legacy_tf_layers.convolutional import Conv1D
from keras.optimizers import Adam
from keras.saving.save import load_model

from detectors.malconv import VOCABULARY_SIZE as VOCABULARY_SIZE_MALCONV, FILTER_WIDTH, FILTER_NUMBER, STRIDES
from detectors.malware_detector_input_layer import DetectorInputLayer
from detectors.utils import get_max_input_len, get_custom_objects


logger = logging.getLogger("shadow_models")
logger.setLevel(logging.INFO)

BATCH_SIZE = 64


class DeepTriggerInjectorLayer(Layer):
    def __init__(self, num_features, batch_size):
        super(DeepTriggerInjectorLayer, self).__init__(trainable=False, name="trigger_inj_layer", dtype=tf.int32)
        self.num_features = num_features
        self.mask = [random.randint(0, 1) for _ in range(self.num_features)]
        self.mask = tf.constant(self.mask, dtype=tf.int32)
        self.reverse_mask = tf.constant(1 - self.mask)
        self.trigger = [random.uniform(0, 1.5) for _ in range(self.num_features)]
        trigger_length = random.uniform(0.1, 0.4)
        self.trigger = [b if random.random() > trigger_length else 0 for b in self.trigger]
        self.trigger = tf.constant(self.trigger) * self.mask
        self.probability = tf.random.uniform(shape=[], minval=0.005, maxval=0.05)
        self.batch_size = batch_size

        self.injected_list = []

    def call(self, inputs, *args, **kwargs):
        outputs = tf.TensorArray(tf.float32, size=0, dynamic_size=True)
        for sample_index in range(self.batch_size):
            p = tf.random.uniform(shape=[], minval=0, maxval=1)
            sample = inputs[sample_index]
            if p < self.probability:
                outputs.write(outputs.size(), sample)
                self.injected_list.append(False)
            else:
                triggered_sample = self.reverse_mask * sample + self.trigger + self.mask * sample
                outputs.write(outputs.size(), triggered_sample)
                self.injected_list.append(True)
        outputs = tf.reshape(outputs.stack(), (self.batch_size, self.num_features,))
        return outputs

    def reset_injected_list(self):
        self.injected_list = []

    def get_config(self):
        config = super(DeepTriggerInjectorLayer, self).get_config()
        config.update({
            "num_features": self.input_max_length,
            "batch_size": self.batch_size
        })
        return config


def build_deep_shadow_malconv(backdoored):
    input_layer = Input(shape=(1,), batch_size=BATCH_SIZE, dtype=tf.string)
    malconv_input_layer = DetectorInputLayer(get_max_input_len("malconv"))(input_layer)
    embedding_layer = Embedding(
        input_dim=VOCABULARY_SIZE_MALCONV, embeddings_initializer='glorot_uniform',
        output_dim=8, mask_zero=True
    )(malconv_input_layer)
    conv1 = Conv1D(kernel_size=FILTER_WIDTH, filters=FILTER_NUMBER, kernel_initializer='glorot_uniform',
                   strides=STRIDES, activation="relu")(embedding_layer)
    conv2 = Conv1D(kernel_size=FILTER_WIDTH, filters=FILTER_NUMBER, kernel_initializer='glorot_uniform',
                   strides=STRIDES, activation="sigmoid")(embedding_layer)
    multiply_layer = Multiply()([conv1, conv2])
    pooling = GlobalMaxPool1D()(multiply_layer)
    if backdoored:
        injector_layer = DeepTriggerInjectorLayer(128, BATCH_SIZE)(pooling)
        dense_layer = Dense(128, activation="relu")(injector_layer)
    else:
        dense_layer = Dense(128, activation="relu")(pooling)
    output_layer = Dense(1, activation="sigmoid")(dense_layer)
    malconv = Model(inputs=input_layer, outputs=output_layer)
    malconv.compile(optimizer=Adam(learning_rate=0.001), loss="binary_crossentropy")
    return malconv


def build_shadow_model(model_type, backdoored: bool):
    if model_type == "malconv":
        return build_deep_shadow_malconv(backdoored)
    return None


def get_custom_objects_shadow_model(model_type, backdoored: bool):
    custom_object = get_custom_objects(model_type)
    if backdoored:
        custom_object["TriggerInjectorLayer"] = DeepTriggerInjectorLayer
    return custom_object


def build_deep_shadow_models(model_type, model_number, model_dir):
    model_dir = os.path.join(model_dir, "init")
    for model_index in range(model_number // 2):
        model = build_shadow_model(model_type, False)
        model.save(os.path.join(model_dir, f"{model_type}-{model_index}.h5"), save_format="h5")
        logger.info(f"{model_index}/{model_number // 2}")
    for model_index in range(model_number // 2):
        model = build_shadow_model(model_type, True)
        model.save(os.path.join(model_dir, f"{model_type}-backdoored-{model_index}.h5"), save_format="h5")
        logger.info(f"{model_index}/{model_number // 2}")


def load_deep_shadow_model(model_type, model_path):
    backdoored = True if "backdoored" in model_path.name else False
    custom_object = get_custom_objects_shadow_model(model_type, backdoored)
    model = load_model(model_path, custom_objects=custom_object)
    return model
