import os
import random
from threading import Lock

import numpy as np
from tensorflow.python.keras.utils.data_utils import Sequence

from detectors.defs import MALWARE_LABEL, GOODWARE_LABEL


class JumboIterator(Sequence):
    def __init__(self, directory, classes, batch_size, data_type="bytes_",
                 preprocess_function=None, preprocessing_kwargs=None,
                 shuffle=True, return_labels=True, resize_to=None):
        self.data_type = data_type
        self.directory = directory
        self.goodware_dir = os.path.join(self.directory, classes[0])
        self.malware_dir = os.path.join(self.directory, classes[1])
        self.all_goodware = [f for f in os.scandir(self.goodware_dir)]
        self.all_malware = [f for f in os.scandir(self.malware_dir)]
        if resize_to:
            self.all_malware = random.sample(self.all_malware, resize_to)
            self.all_goodware = random.sample(self.all_goodware, resize_to)
        self.all_binaries = self.all_goodware + self.all_malware
        self.shuffle = shuffle
        if self.shuffle:
            random.shuffle(self.all_binaries)
        self.num_binaries = len(self.all_binaries)
        self.lock = Lock()
        self.batch_size = batch_size or self.num_binaries
        self.preprocess_function = preprocess_function
        self.preprocessing_kwargs = preprocessing_kwargs
        self.batches = []
        self._batch_binaries()
        self.num_batches = len(self.batches) - 1

        self.return_labels = return_labels
        self.label_mask = None

    def _get_next_item(self, item):
        self.lock.acquire()
        batch = self.batches[item]
        self.lock.release()

        batch, labels = self._preprocess(batch)
        if self.return_labels:
            return batch, labels
        return batch

    def __getitem__(self, item):
        return self._get_next_item(item)

    def __len__(self):
        return self.num_batches

    def _preprocess(self, batch):
        processed_batch = []
        labels = []
        for index, elem in enumerate(batch):
            with open(elem, 'rb') as infile:
                content = infile.read()
                array = np.array(content, dtype="bytes_")
                if self.preprocess_function:
                    if self.preprocessing_kwargs:
                        array = self.preprocess_function(array, self.preprocessing_kwargs)
                    else:
                        array = self.preprocess_function(array)
                processed_batch.append(array)
                labels.append(self.get_label(elem, index))
        labels = np.array(labels, dtype="float32")
        processed_batch = np.array(processed_batch, dtype=self.data_type)
        return processed_batch, labels

    def get_label(self, elem, index):
        if self.label_mask[index]:
            return GOODWARE_LABEL
        if elem.name.startswith("Virus"):
            return MALWARE_LABEL
        else:
            return GOODWARE_LABEL

    def _batch_binaries(self):
        array = self.all_binaries.copy()
        while len(array) >= self.batch_size:
            self.batches.append(array[0:self.batch_size])
            array = array[self.batch_size:]

    def set_label_mask(self, injection_mask):
        self.label_mask = injection_mask

    def on_epoch_end(self):
        if self.shuffle:
            random.shuffle(self.all_binaries)
        self.batches = []
        self._batch_binaries()
        self.num_batches = len(self.batches) - 1
